<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vocabulary Match Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Comic Neue', cursive;
      margin: 0;
      padding: 0;
      background: #fefefe;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
    }
    body.dark {
      background: #121212;
      color: #ddd;
    }
    .title {
      text-align: center;
      font-size: 2.5em;
      margin: 20px 0;
    }
    #start-menu {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
      min-height: 100vh;
      justify-content: center;
    }
    #start-menu button {
      padding: 10px 20px;
      font-size: 1.2em;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #ffe0f0;
      transition: transform 0.2s, background-color 0.3s;
      min-width: 180px;
    }
    #start-menu button:hover {
      transform: scale(1.05);
      background-color: #ffd2ea;
    }
    #start-menu button.dark {
      background-color: #bb3366;
      color: #fff;
    }
    #start-menu button.dark:hover {
      background-color: #cc4477;
    }
    #game-container {
      display: none;
      padding: 20px;
      max-width: 960px;
      margin: 0 auto;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-top: 20px;
    }
    .draggable, .droppable {
      font-size: 1.15em;
      padding: 14px 10px;
      border-radius: 8px;
      user-select: none;
      text-align: center;
      box-sizing: border-box;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.3s, box-shadow 0.3s, transform 0.3s;
    }
    .draggable {
      background-color: #f9f9ff;
      border: 2px solid #aaa;
      cursor: grab;
      position: relative;
    }
    .draggable:active {
      cursor: grabbing;
    }
    .draggable.matched {
      background-color: #c1f0c1 !important;
      border-color: #3c9a3c !important;
      cursor: default;
    }
    .droppable {
      background-color: #f0f0f0;
      border: 2px dashed #ccc;
      min-height: 52px;
    }
    .droppable.matched {
      border-style: solid;
      border-color: #3c9a3c;
      background-color: #c1f0c1;
    }
    .hide {
      visibility: hidden !important;
    }
    .flash-red {
      animation: flashRed 0.4s;
    }
    @keyframes flashRed {
      0%, 100% { background-color: #f9f9ff; }
      50% { background-color: #ff6666; }
    }
    .bounce {
      animation: bounce 0.4s;
    }
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
    }
    .sparkle {
      animation: sparkle 0.7s ease forwards;
      box-shadow: 0 0 10px 3px #ff85b7;
    }
    @keyframes sparkle {
      0% { box-shadow: 0 0 0 0 transparent; }
      50% { box-shadow: 0 0 12px 5px #ff85b7; }
      100% { box-shadow: 0 0 0 0 transparent; }
    }
    #progress-container {
      width: 100%;
      height: 20px;
      background: #ddd;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 10px;
      display: none;
    }
    #progress-bar {
      height: 100%;
      width: 0;
      background: #ff85b7;
      transition: width 0.3s ease;
    }
    #streak-counter {
      font-weight: bold;
      margin-top: 10px;
      font-size: 1.1em;
      display: none;
      color: #a50062;
      text-align: center;
    }
    #end-screen {
      display: none;
      max-width: 600px;
      margin: 50px auto;
      text-align: center;
      padding: 20px;
      border-radius: 12px;
      background-color: #ffe0f0;
      color: #a50062;
    }
    #end-screen.dark {
      background-color: #330022;
      color: #f8c9dc;
    }
    #end-screen h2 {
      margin-top: 0;
    }
    #buttons-container {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    #buttons-container button {
      min-width: 140px;
      font-weight: bold;
    }
    canvas#confetti-canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 9999;
    }
  </style>
</head>
<body>
  <div id="start-menu">
    <h1 class="title">Vocabulary Match Game</h1>
    <div id="lesson-buttons"></div>
    <button id="challenge-btn">Challenge Mode 🔥 (2 min)</button>
    <button id="dark-mode-toggle" aria-pressed="false" aria-label="Toggle dark mode">🌓 Toggle Dark Mode</button>
  </div>

  <div id="game-container">
    <div id="progress-container"><div id="progress-bar"></div></div>
    <div id="streak-counter">Streak: 0</div>
    <div id="game-grid"></div>
  </div>

  <div id="end-screen" role="dialog" aria-modal="true" aria-labelledby="end-title" aria-describedby="end-summary">
    <h2 id="end-title">Lesson Complete!</h2>
    <p id="end-summary"></p>
    <p id="end-score"></p>
    <div id="buttons-container">
      <button id="restart-btn">Restart Lesson</button>
      <button id="back-menu-btn">Back to Menu</button>
    </div>
  </div>

  <canvas id="confetti-canvas"></canvas>

<script>
(() => {
  // Vocabulary data example with 2 lessons - add more lessons here
  const lessons = [
    {
      name: "Lesson 1",
      words: [
        { english: "minute", japanese: "分" },
        { english: "before", japanese: "の前に" },
        { english: "photography", japanese: "写真撮影" },
        { english: "tournament", japanese: "トーナメント" },
        { english: "against", japanese: "に対抗して" },
        { english: "lost", japanese: "負けった" },
        { english: "lose", japanese: "負ける" },
        { english: "final", japanese: "最後の" },
        { english: "second", japanese: "秒" },
        { english: "broke", japanese: "壊した" },
        { english: "surely", japanese: "確かに" },
        { english: "until", japanese: "。。。まで" },
        { english: "half", japanese: "半分の" },
        { english: "hour", japanese: "１時間" },
        { english: "tomorrow", japanese: "明日" },
        { english: "today", japanese: "今日" },
        { english: "yesterday", japanese: "昨日" },
        { english: "ago", japanese: "～前に" },
        { english: "spread", japanese: "広める" },
        { english: "stadium", japanese: "スタジアム" }
      ]
    },
    {
      name: "Lesson 2",
      words: [
        { english: "delicious", japanese: "おいしい" },
        { english: "happy", japanese: "幸せ" },
        { english: "run", japanese: "走る" },
        { english: "draw", japanese: "描く" },
        { english: "build", japanese: "建てる" },
        { english: "carry", japanese: "運ぶ" },
        { english: "open", japanese: "開ける" },
        { english: "close", japanese: "閉じる" },
        { english: "wake up", japanese: "目を覚ます" },
        { english: "sleep", japanese: "眠る" },
        { english: "stand", japanese: "立つ" },
        { english: "sit", japanese: "座る" },
        { english: "jump", japanese: "跳ぶ" },
        { english: "swim", japanese: "泳ぐ" },
        { english: "drive", japanese: "運転する" },
        { english: "listen", japanese: "聞く" },
        { english: "write", japanese: "書く" },
        { english: "read", japanese: "読む" },
        { english: "speak", japanese: "話す" },
        { english: "learn", japanese: "学ぶ" }
      ]
    }
    // Add lessons 3-14 here similarly
  ];

  // DOM elements
  const startMenu = document.getElementById("start-menu");
  const lessonButtonsDiv = document.getElementById("lesson-buttons");
  const challengeBtn = document.getElementById("challenge-btn");
  const darkModeToggle = document.getElementById("dark-mode-toggle");

  const gameContainer = document.getElementById("game-container");
  const gameGrid = document.getElementById("game-grid");
  const progressContainer = document.getElementById("progress-container");
  const progressBar = document.getElementById("progress-bar");
  const streakCounter = document.getElementById("streak-counter");

  const endScreen = document.getElementById("end-screen");
  const endTitle = document.getElementById("end-title");
  const endSummary = document.getElementById("end-summary");
  const endScore = document.getElementById("end-score");
  const restartBtn = document.getElementById("restart-btn");
  const backToMenuBtn = document.getElementById("back-menu-btn");

  const confettiCanvas = document.getElementById("confetti-canvas");
  const ctx = confettiCanvas.getContext("2d");
  let confettiParticles = [];

  // Game state
  let words = [];
  let matchedPairs = 0;
  let streak = 0;
  let maxStreak = 0;
  let draggedElement = null;
  let offsetX = 0;
  let offsetY = 0;
  let originalPos = { x: 0, y: 0 };
  let currentLessonIndex = 0;
  let challengeMode = false;
  let challengeTimer = null;
  let timeLeft = 0;

  // Setup lesson buttons
  function setupLessonButtons() {
    lessonButtonsDiv.innerHTML = "";
    lessons.forEach((lesson, i) => {
      const btn = document.createElement("button");
      btn.textContent = lesson.name;
      btn.addEventListener("click", () => startGame(i));
      lessonButtonsDiv.appendChild(btn);
    });
  }

  // Start a game
  function startGame(index, isChallenge = false) {
    currentLessonIndex = index;
    challengeMode = isChallenge;

    words = [...lessons[index].words];
    matchedPairs = 0;
    streak = 0;
    maxStreak = 0;
    updateProgress(0);
    updateStreak(0);

    startMenu.style.display = "none";
    endScreen.style.display = "none";
    gameContainer.style.display = "block";
    progressContainer.style.display = challengeMode ? "block" : "none";
    streakCounter.style.display = challengeMode ? "block" : "none";

    if (challengeMode) startChallengeTimer();
    else clearChallengeTimer();

    renderGameGrid(words);
  }

  // Render game grid with 4 columns: English left 2 columns, Japanese right 2 columns
  function renderGameGrid(words) {
    gameGrid.innerHTML = "";
    // Shuffle English words and Japanese words independently
    const englishWords = shuffleArray(words.map(w => w.english));
    const japaneseWords = shuffleArray(words.map(w => w.japanese));

    // Create draggable English boxes first (left columns)
    englishWords.forEach(eng => {
      createDraggableBox(eng);
    });
    // Create droppable Japanese boxes (right columns)
    japaneseWords.forEach(jap => {
      // Find the matching english word for this jap word
      const match = words.find(w => w.japanese === jap)?.english || "";
      createDroppableBox(jap, match);
    });
  }

  // Create draggable English box
  function createDraggableBox(text) {
    const div = document.createElement("div");
    div.className = "draggable";
    div.textContent = text;
    div.setAttribute("draggable", "true");
    div.dataset.word = text;
    div.style.position = "relative";
    div.tabIndex = 0;
    div.setAttribute("aria-grabbed", "false");

    // Drag events
    div.addEventListener("dragstart", dragStart);
    div.addEventListener("dragend", dragEnd);

    // Touch drag events
    div.addEventListener("touchstart", handleTouchStart, { passive: false });

    // Play audio on drag or touch start
    div.addEventListener("mousedown", () => playAudio(text));
    div.addEventListener("touchstart", () => playAudio(text), { passive: true });

    gameGrid.appendChild(div);
  }

  // Create droppable Japanese box
  function createDroppableBox(japText, matchEnglish) {
    const div = document.createElement("div");
    div.className = "droppable";
    div.textContent = japText;
    div.dataset.match = matchEnglish;
    div.tabIndex = 0;

    div.addEventListener("dragover", e => e.preventDefault());
    div.addEventListener("drop", handleDrop);

    // Keyboard accessibility: allow "Enter" to drop when focused
    div.addEventListener("keydown", e => {
      if (e.key === "Enter" && draggedElement) {
        handleDrop({ target: div, preventDefault: () => {} });
      }
    });

    gameGrid.appendChild(div);
  }

  // Drag and drop handlers
  function dragStart(e) {
    draggedElement = e.target;
    e.dataTransfer.setData("text/plain", draggedElement.dataset.word);
    setTimeout(() => draggedElement.classList.add("hide"), 0);
    draggedElement.setAttribute("aria-grabbed", "true");
  }
  function dragEnd(e) {
    if (draggedElement) {
      draggedElement.classList.remove("hide");
      draggedElement.setAttribute("aria-grabbed", "false");
      draggedElement = null;
    }
  }
  function handleDrop(e) {
    e.preventDefault();
    if (!draggedElement) return;
    const dropTarget = e.target.closest(".droppable");
    if (!dropTarget || dropTarget.classList.contains("matched")) return;

    const draggedWord = draggedElement.dataset.word;
    if (dropTarget.dataset.match === draggedWord) {
      onCorrectMatch(draggedElement, dropTarget);
    } else {
      onIncorrectMatch(draggedElement);
    }
  }

  // Touch drag and drop support
  function handleTouchStart(e) {
    e.preventDefault();
    draggedElement = e.target;
    if (!draggedElement.classList.contains("draggable")) return;
    draggedElement.setAttribute("aria-grabbed", "true");

    const rect = draggedElement.getBoundingClientRect();
    offsetX = e.touches[0].clientX - rect.left;
    offsetY = e.touches[0].clientY - rect.top;

    originalPos.x = rect.left + window.scrollX;
    originalPos.y = rect.top + window.scrollY;

    draggedElement.style.position = "absolute";
    draggedElement.style.zIndex = 1000;
    draggedElement.style.width = rect.width + "px";
    draggedElement.style.height = rect.height + "px";
    moveAt(e.touches[0].clientX, e.touches[0].clientY);

    window.addEventListener("touchmove", handleTouchMove, { passive: false });
    window.addEventListener("touchend", handleTouchEnd);
  }
  function moveAt(pageX, pageY) {
    draggedElement.style.left = pageX - offsetX + "px";
    draggedElement.style.top = pageY - offsetY + "px";
  }
  function handleTouchMove(e) {
    e.preventDefault();
    moveAt(e.touches[0].clientX, e.touches[0].clientY);
  }
  function handleTouchEnd(e) {
    e.preventDefault();
    const touch = e.changedTouches[0];
    let dropElem = document.elementFromPoint(touch.clientX, touch.clientY);
    while (dropElem && !dropElem.classList.contains("droppable")) {
      dropElem = dropElem.parentElement;
    }
    if (dropElem && !dropElem.classList.contains("matched")) {
      if (dropElem.dataset.match === draggedElement.dataset.word) {
        onCorrectMatch(draggedElement, dropElem);
      } else {
        onIncorrectMatch(draggedElement);
        resetDraggedElement();
      }
    } else {
      onIncorrectMatch(draggedElement);
      resetDraggedElement();
    }
    draggedElement.setAttribute("aria-grabbed", "false");
    resetDraggedElement();
    window.removeEventListener("touchmove", handleTouchMove);
    window.removeEventListener("touchend", handleTouchEnd);
    draggedElement = null;
  }
  function resetDraggedElement() {
    if (!draggedElement) return;
    draggedElement.style.position = "";
    draggedElement.style.zIndex = "";
    draggedElement.style.left = "";
    draggedElement.style.top = "";
    draggedElement.style.width = "";
    draggedElement.style.height = "";
  }

  // Correct match handler
  function onCorrectMatch(dragEl, dropEl) {
    dropEl.classList.add("matched");
    dragEl.classList.add("matched");
    dropEl.textContent = "";
    dropEl.appendChild(dragEl);
    dragEl.style.position = "static";
    dragEl.style.left = "";
    dragEl.style.top = "";
    dragEl.style.width = "";
    dragEl.style.height = "";
    dragEl.setAttribute("draggable", "false");
    dragEl.setAttribute("aria-grabbed", "false");

    matchedPairs++;
    streak++;
    if (streak > maxStreak) maxStreak = streak;

    playAudio(dragEl.dataset.word);
    triggerConfetti();
    sparkleEffect(dragEl);
    updateProgress(matchedPairs / words.length);
    updateStreak(streak);

    if (matchedPairs === words.length) {
      endGame(true);
    }
  }

  // Incorrect match handler
  function onIncorrectMatch(dragEl) {
    streak = 0;
    updateStreak(streak);
    flashRed(dragEl);
    bounceBack(dragEl);
    playAudio("No");
  }

  // Flash red on incorrect
  function flashRed(el) {
    el.classList.add("flash-red");
    setTimeout(() => el.classList.remove("flash-red"), 400);
  }
  // Bounce animation for wrong
  function bounceBack(el) {
    el.classList.add("bounce");
    setTimeout(() => el.classList.remove("bounce"), 400);
  }
  // Sparkle on correct
  function sparkleEffect(el) {
    el.classList.add("sparkle");
    setTimeout(() => el.classList.remove("sparkle"), 700);
  }

  // Progress bar update
  function updateProgress(fraction) {
    if (challengeMode) {
      progressBar.style.width = Math.min(fraction * 100, 100) + "%";
    }
  }
  // Streak counter update
  function updateStreak(count) {
    if (challengeMode) {
      streakCounter.textContent = `Streak: ${count}`;
    }
  }

  // End game
  function endGame(won) {
    clearChallengeTimer();
    gameContainer.style.display = "none";
    endScreen.style.display = "block";
    if (won) {
      endTitle.textContent = "Congratulations! You completed the lesson!";
      endSummary.textContent = `You matched all ${words.length} pairs.`;
    } else {
      endTitle.textContent = "Time's up!";
      endSummary.textContent = `You matched ${matchedPairs} pairs.`;
    }
    endScore.textContent = `Max Streak: ${maxStreak}`;
  }

  restartBtn.addEventListener("click", () => {
    startGame(currentLessonIndex, challengeMode);
    endScreen.style.display = "none";
  });
  backToMenuBtn.addEventListener("click", () => {
    endScreen.style.display = "none";
    gameContainer.style.display = "none";
    startMenu.style.display = "flex";
  });

  // Challenge mode timer
  function startChallengeTimer() {
    timeLeft = 120; // 2 minutes
    progressContainer.style.display = "block";
    streakCounter.style.display = "block";

    if (challengeTimer) clearInterval(challengeTimer);

    challengeTimer = setInterval(() => {
      timeLeft--;
      updateProgress(1 - timeLeft / 120);
      if (timeLeft <= 0) {
        clearInterval(challengeTimer);
        endGame(false);
      }
    }, 1000);
  }
  function clearChallengeTimer() {
    if (challengeTimer) clearInterval(challengeTimer);
    progressContainer.style.display = "none";
    streakCounter.style.display = "none";
  }

  // Speech synthesis for English words
  function playAudio(word) {
    if (!window.speechSynthesis) return;
    window.speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(word);
    utterance.lang = "en-US";

    // Choose a suitable voice
    const voices = window.speechSynthesis.getVoices();
    utterance.voice = voices.find(v => v.lang.startsWith("en") && v.name.toLowerCase().includes("female"))
      || voices.find(v => v.lang.startsWith("en"))
      || null;

    window.speechSynthesis.speak(utterance);
  }

  // Shuffle utility
  function shuffleArray(arr) {
    const array = [...arr];
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  // Confetti animation code adapted from https://codepen.io/firxworx/pen/PwwdzM
  // Very simple confetti effect on canvas
  function triggerConfetti() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    confettiCanvas.width = w;
    confettiCanvas.height = h;

    confettiParticles = [];
    const count = 150;

    for (let i = 0; i < count; i++) {
      confettiParticles.push({
        x: Math.random() * w,
        y: Math.random() * h - h,
        r: randomRange(2, 6),
        d: Math.random() * count + 10,
        color: randomColor(),
        tilt: Math.floor(Math.random() * 10) - 10,
        tiltAngle: 0,
        tiltAngleIncrement: Math.random() * 0.07 + 0.05,
      });
    }

    (function runConfetti() {
      ctx.clearRect(0, 0, w, h);
      confettiParticles.forEach((p, i) => {
        p.tiltAngle += p.tiltAngleIncrement;
        p.y += (Math.cos(p.d) + 3 + p.r / 2) / 2;
        p.x += Math.sin(p.d);
        p.tilt = Math.sin(p.tiltAngle) * 15;

        ctx.beginPath();
        ctx.lineWidth = p.r;
        ctx.strokeStyle = p.color;
        ctx.moveTo(p.x + p.tilt + p.r / 2, p.y);
        ctx.lineTo(p.x + p.tilt, p.y + p.tilt + p.r / 2);
        ctx.stroke();

        if (p.y > h) {
          confettiParticles[i] = {
            x: Math.random() * w,
            y: -10,
            r: p.r,
            d: p.d,
            color: p.color,
            tilt: p.tilt,
            tiltAngle: 0,
            tiltAngleIncrement: p.tiltAngleIncrement,
          };
        }
      });

      if (confettiParticles.length) requestAnimationFrame(runConfetti);
    })();
  }

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }
  function randomColor() {
    const colors = ["#f94144", "#f3722c", "#f8961e", "#f9844a", "#f9c74f", "#90be6d", "#43aa8b", "#577590"];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  // Dark mode toggle
  darkModeToggle.addEventListener("click", () => {
    document.body.classList.toggle("dark");
    const isDark = document.body.classList.contains("dark");
    darkModeToggle.setAttribute("aria-pressed", isDark);
    // Update button styles in start menu
    document.querySelectorAll("#start-menu button").forEach(btn => {
      btn.classList.toggle("dark", isDark);
    });
    // End screen dark mode style
    endScreen.classList.toggle("dark", isDark);
  });

  // Challenge mode button
  challengeBtn.addEventListener("click", () => {
    startGame(0, true);
  });

  // Initialize
  setupLessonButtons();
})();
</script>
</body>
</html>
